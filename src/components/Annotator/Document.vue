<template>
    <div>
        <div class="card instruction">
          <div class="card-header my-header">
              Instructions
          </div>
            <!-- eslint-disable -->
          <div class="card-body">
            <h5 class="card-title my-title">Task Description</h5>
            <p class="card-text my-text">Your task is to select important phrases from the document by highlighting them.</p>
            <p class="card-text my-text">Select phrases that are the most informative, optionally you may follow the 5W1H (who, what, when, where, why and how) guidance.</p>
            <h5 class="card-title my-title">Create Highlights and Delete Them: How-To</h5>
            <p class="card-text my-text">To highlight, use your mouse to select phrases from the document, when you have finished, selected words will automatically count as a group of highlight.</p>
            <p class="card-text my-text">To delete a group of highlights, right click on the highlight.</p>
            <h5 class="card-title my-title">Shows Related Works by Co-Reference: How-To.</h5>
            <p class="card-text my-text">Clicking on phrase that are colored as blue will show you related phrases that are referring to them. This is automatically generated by system.</p>
          </div>
            <!-- eslint-enable -->
        </div>
        <div class="card summary">
          <div class="card-header my-header">
              Your Selected Summaries
          </div>
          <div class="card-body">
            <h5 class="card-title my-title">Phrases:</h5>
            <p class="card-text my-text" v-html="rawSummariesHTML"></p>
            <router-link
              :to="{ name: 'surveyForm',
              params: {groups: this.groups}}"
              tag='button' class="btn btn-primary">
                Submit
            </router-link>
          </div>
        </div>
        <div ref="document" v-on:mouseup="showHighlightMenu"
             @contextmenu.prevent="deleteHighlightGroup" v-on:click="showMentions">
        </div>
        <div v-bind:style="floatMenu">
            <img v-on:click="highlightSelection"
                 src="../../assets/highlight_menu.png"
                 width="55" alt="Highlight">
        </div>
    </div>
</template>

<script>
import Word from '@/components/Annotator/Word.vue';
import Char from '@/components/Annotator/Char.vue';
import LineBreaker from '@/components/Annotator/LineBreaker.vue';
import Vue from 'vue';

const randomColor = require('randomcolor');
const axios = require('axios');

function createAndMountWord(sent, token, wordIndex, isSourceAndCorefID) {
  const WordClass = Vue.extend(Word);
  const word = new WordClass({
    propsData: {
      sentIndex: sent.index,
      tokenIndex: token.index,
      word: token.word,
      index: wordIndex,
      type: 'word',
      // eslint-disable-next-line
      isSource: isSourceAndCorefID.isSource,
    },
  });
  word.$mount();
  if (isSourceAndCorefID.isSource === true) {
    this.words2corefID[wordIndex] = isSourceAndCorefID.corefID;
  }
  this.words[wordIndex] = word;
  this.words2Groups[wordIndex] = [];
  this.$refs.document.appendChild(word.$el);
}

function createAndMountWhitespace(whitespace, whitespaceIndex) {
  const CharClass = Vue.extend(Char);
  const char = new CharClass({
    propsData: {
      bgColor: '#ffffff',
      type: 'whitespace',
      index: whitespaceIndex,
    },
  });
  char.$slots.default = [whitespace];
  char.$mount();
  this.whitespaces[whitespaceIndex] = char;
  this.whitespaces2Groups[whitespaceIndex] = [];
  this.$refs.document.appendChild(char.$el);
}

function createAndMountLineBreaker() {
  const LineBreakerClass = Vue.extend(LineBreaker);
  const lineBreaker = new LineBreakerClass();
  lineBreaker.$mount();
  this.$refs.document.appendChild(lineBreaker.$el);
}

function generateRawHTMLSummaries() {
  this.rawSummariesHTML = '';
  let rawHTML = '';
  for (let i = 0; i < Object.keys(this.groups).length; i += 1) {
    const key = Object.keys(this.groups)[i];
    rawHTML = `<p style='background-color: ${this.group2color[key]}'>${i + 1}: `;
    for (let j = 0; j < this.groups[key].length; j += 1) {
      const component = this.groups[key][j];
      if (component.$props.type === 'word') {
        rawHTML = `${rawHTML} ${component.$props.word}`;
      }
    }
    rawHTML = `${rawHTML}</p>`;
    this.rawSummariesHTML = `${this.rawSummariesHTML}${rawHTML}`;
  }
}

function populateCoref(textJSON) {
  const reverseCorefs = {};
  Object.keys(textJSON.corefs).forEach((ID) => {
    const corefID = parseInt(ID, 10);
    const newCorefID = textJSON.corefs[corefID][0].id;
    if (!(newCorefID in reverseCorefs)) {
      reverseCorefs[newCorefID] = [];
    }
    for (let i = 0; i < textJSON.corefs[corefID].length; i += 1) {
      reverseCorefs[newCorefID].push(textJSON.corefs[corefID][i]);
    }
  });
  Object.keys(reverseCorefs).forEach((ID) => {
    const corefID = parseInt(ID, 10);
    for (let i = 0; i < reverseCorefs[corefID].length; i += 1) {
      const mention = reverseCorefs[corefID][i];
      if (!(corefID in this.source2mentions)) {
        this.source2mentions[corefID] = [];
      }
      this.source2mentions[corefID].push(mention.id);
      if (!(mention.id in this.mentions)) {
        this.mentions[mention.id] = {
          id: mention.id,
          startIndex: mention.startIndex,
          endIndex: mention.endIndex,
          sentIndex: mention.sentNum,
        };
      }
      if (corefID === mention.id) {
        if (!(mention.sentNum in this.sent2source)) {
          this.sent2source[mention.sentNum] = [];
        }
        this.sent2source[mention.sentNum].push(corefID);
      }
    }
  });
}

function getIsSourceAndcorefID(sent, token) {
  if (sent.index + 1 in this.sent2source) {
    const corefIDs = this.sent2source[sent.index + 1];
    for (let k = 0; k < corefIDs.length; k += 1) {
      if (token.index >= this.mentions[corefIDs[k]].startIndex &&
          token.index < this.mentions[corefIDs[k]].endIndex) {
        return {
          isSource: true,
          corefID: corefIDs[k],
        };
      }
    }
  }
  return false;
}

function parseDoc(textJSON) {
  let wordIndex = 0;
  let whitespaceIndex = 0;
  populateCoref.call(this, textJSON);
  for (let i = 0; i < textJSON.sentences.length; i += 1) {
    const sent = textJSON.sentences[i];
    for (let j = 0; j < sent.tokens.length; j += 1) {
      const token = sent.tokens[j];
      const isSourceAndCorefID = getIsSourceAndcorefID.call(this, sent, token);
      if (j === 0 && ((sent.index + 1) % 3 === 0)) {
        createAndMountLineBreaker.call(this);
      }
      createAndMountWord.call(this, sent, token, wordIndex, isSourceAndCorefID);
      // check is last element
      if (j !== sent.tokens.length - 2) {
        createAndMountWhitespace.call(this, ' ', whitespaceIndex);
        whitespaceIndex += 1;
      }
      wordIndex += 1;
    }
  }
}

function getFile() {
  axios.post('json')
    .then((response) => {
      parseDoc.call(this, response.data);
    })
    .catch(() => {
    })
    .then(() => {

    });
}

// function saveResult() {
//   axios.post()
// }

function clearSelection(selection) {
  if (selection) {
    if (selection.empty) { // Chrome
      selection.empty();
    } else if (selection.removeAllRanges) { // Firefox
      selection.removeAllRanges();
    }
  }
}

function getSelection() {
  if (window.getSelection) {
    return window.getSelection();
  } else if (document.getSelection) {
    return document.getSelection();
  } else if (document.selection) {
    return document.selection.createRange().text;
  }
  return null;
}

function getTopWhitespaceGroup(index) {
  if (this.whitespaces2Groups[index].length === 0) {
    return -1;
  }
  return this.whitespaces2Groups[index][this.whitespaces2Groups[index].length - 1];
}

function getTopWordGroups(index) {
  if (this.words2Groups[index].length === 0) {
    return -1;
  }
  return this.words2Groups[index][this.words2Groups[index].length - 1];
}

function tempStoreComponent(component, type, groupKey) {
  const components = [];
  let found = false;
  this.groups[groupKey].forEach((aComponent) => {
    if (aComponent === component) {
      found = true;
    }
  });
  if (found === false) {
    components.push(component);
  }
  return components;
}

function highlightAndAddComponentToGroup(
  whitespaceSelectedComponents,
  wordSelectedComponents,
  color, groupKey,
) {
  for (let i = 0; i < whitespaceSelectedComponents.length; i += 1) {
    const component = whitespaceSelectedComponents[i];
    this.groups[groupKey].push(component);
    this.whitespaces2Groups[component.index].push(groupKey);
    component.$data.charStyle['background-color'] = color;
  }
  for (let i = 0; i < wordSelectedComponents.length; i += 1) {
    const component = wordSelectedComponents[i];
    this.groups[groupKey].push(component);
    this.words2Groups[component.index].push(groupKey);
    component.highlight(color);
  }
}

export default {
  name: 'Document',
  data() {
    return {
      whitespaces: {},
      words: {},
      whitespaces2Groups: {},
      words2Groups: {},
      groups: {},
      floatMenu: {
        display: 'none',
      },
      sent2source: {},
      mentions: {},
      source2mentions: {},
      words2corefID: {},
      annotatedWords: [],
      group2color: {},
      usedColor: [],
      rawSummariesHTML: '',
    };
  },
  methods: {
    showMentions(event) {
      let corefID = -1;
      if (event.target.parentElement.dataset.type === 'word') {
        corefID = this.words2corefID[event.target.parentElement.dataset.index];
      } else if (event.target.parentElement.dataset.type === 'char') {
        corefID = this.words2corefID[event.target.parentElement.parentElement.dataset.index];
      }
      if (corefID !== -1) {
        for (let i = 0; i < this.annotatedWords.length; i += 1) {
          this.annotatedWords[i].resetAnnotation();
        }
        this.annotatedWords = [];
        const mentions = this.source2mentions[corefID];
        for (let i = 0; i < Object.keys(this.words).length; i += 1) {
          const index = Object.keys(this.words)[i];
          const { tokenIndex } = this.words[index];
          for (let j = 0; j < mentions.length; j += 1) {
            if (this.words[index].sentIndex + 1 === this.mentions[mentions[j]].sentIndex &&
              tokenIndex >= this.mentions[mentions[j]].startIndex &&
              tokenIndex < this.mentions[mentions[j]].endIndex) {
              this.words[index].annotate();
              if (j === 1) {
                this.words[index].$refs.word.scrollIntoView();
                window.scrollBy(0, -1 * (window.innerHeight / 10));
              }
              this.annotatedWords.push(this.words[index]);
            }
          }
        }
      }
    },
    deleteHighlightGroup(event) {
      let groupIndex = -1;
      if (event.target.parentElement.dataset.type === 'whitespace') {
        groupIndex = getTopWhitespaceGroup.call(this, event.target.parentElement.dataset.index);
      } else if (event.target.parentElement.dataset.type === 'word') {
        groupIndex = getTopWordGroups.call(this, event.target.parentElement.dataset.index);
      } else if (event.target.parentElement.dataset.type === 'char') {
        groupIndex = getTopWordGroups.call(
          this,
          event.target.parentElement.parentElement.dataset.index,
        );
      }
      if (groupIndex !== -1) {
        if (window.confirm('Do you want to delete the highlights?')) {
          this.groups[groupIndex].forEach((component) => {
            if (component.$props.type === 'whitespace') {
              for (let i = 0; i < this.whitespaces2Groups[component.$props.index].length; i += 1) {
                if (this.whitespaces2Groups[component.$props.index][i] === groupIndex) {
                  this.whitespaces2Groups[component.$props.index].splice(i, 1);
                  if (this.whitespaces2Groups[component.$props.index].length === 0) {
                    // eslint-disable-next-line
                    component.$data.charStyle['background-color'] = '#ffffff';
                  }
                  break;
                }
              }
            } else if (component.$props.type === 'word') {
              for (let i = 0; i < this.words2Groups[component.$props.index].length; i += 1) {
                if (this.words2Groups[component.$props.index][i] === groupIndex) {
                  this.words2Groups[component.$props.index].splice(i, 1);
                  if (this.words2Groups[component.$props.index].length === 0) {
                    // eslint-disable-next-line
                    component.rmHighlight();
                  }
                  break;
                }
              }
            }
          });
          if (groupIndex in this.groups) {
            delete this.groups[groupIndex];
          }
          let sumOfWords = 0;
          // eslint-disable-next-line
          for (const key in this.words2Groups) {
            if (this.words2Groups[key].length > 0) {
              sumOfWords += 1;
            }
          }
          this.$emit('highlight', sumOfWords);
          generateRawHTMLSummaries.call(this);
        }
      }
    },
    highlightSelection() {
      // Generate new group key
      let groupKey = 0;
      Object.keys(this.groups).forEach((key) => {
        groupKey = parseInt(key, 10) + 1;
      });
      this.groups[groupKey] = [];
      const color = randomColor({
        luminosity: 'light',
      });
      this.group2color[groupKey] = color;
      const selection = getSelection();
      const range = selection.getRangeAt(0);
      const iterator = document.createNodeIterator(
        range.commonAncestorContainer,
        NodeFilter.SHOW_ALL, // pre-filter
        {
          acceptNode() {
            return NodeFilter.FILTER_ACCEPT;
          },
        },
      );
      const nodes = [];
      // Add selected component to storage
      let whitespaceSelectedComponents = [];
      let wordSelectedComponents = [];
      while (iterator.nextNode()) {
        // eslint-disable-next-line
        if (nodes.length === 0 && iterator.referenceNode !== range.startContainer) continue;
        nodes.push(iterator.referenceNode);
        if (iterator.referenceNode.parentElement.dataset.type === 'whitespace') {
          // eslint-disable-next-line
          const index = iterator.referenceNode.parentElement.dataset.index;
          whitespaceSelectedComponents =
            whitespaceSelectedComponents.concat(tempStoreComponent.call(this, this.whitespaces[index], 'char', groupKey));
        }
        if (iterator.referenceNode.parentElement.dataset.type === 'word') {
          // eslint-disable-next-line
          const index = iterator.referenceNode.parentElement.dataset.index;
          if (!(wordSelectedComponents.includes(this.words[index]))) {
            wordSelectedComponents =
              wordSelectedComponents.concat(tempStoreComponent.call(this, this.words[index], 'word', groupKey));
          }
        }
        if (iterator.referenceNode === range.endContainer) break;
      }
      let sumOfWords = 0;
      // eslint-disable-next-line
      for (const key in this.words2Groups) {
        if (this.words2Groups[key].length > 0) {
          sumOfWords += 1;
        }
      }
      for (let i = 0; i < wordSelectedComponents.length; i += 1) {
        const word = wordSelectedComponents[i];
        if (this.words2Groups[word.index].length === 0) {
          sumOfWords += 1;
        }
      }
      if (sumOfWords <= 100) {
        highlightAndAddComponentToGroup.call(
          this, whitespaceSelectedComponents, wordSelectedComponents,
          color, groupKey,
        );
        this.$emit('highlight', sumOfWords);
        generateRawHTMLSummaries.call(this);
      } else {
        alert('Your highlights have passed the 100 words limit. Remove previous highlights or shorten the highlights.');
        delete this.group2color[groupKey];
        delete this.groups[groupKey];
      }

      // Clear selection
      this.floatMenu.display = 'none';
      clearSelection(selection);
    },
    showHighlightMenu(event) {
      const selection = getSelection();
      if (!(selection.toString() === '')) {
        this.floatMenu.display = 'block';
        this.floatMenu.position = 'fixed';
        this.$set(this.floatMenu, 'left', `${event.pageX - 10}px`);
        this.$set(this.floatMenu, 'top', `${event.pageY - (window.scrollY - 20)}px`);
      } else {
        this.floatMenu.display = 'none';
      }
    },
  },
  mounted: function onMounted() {
    getFile.call(this);
    // readFile.call(this, '/static/gold_doc/doc.json');
  },
};
</script>

<style scoped>
.summary {
    position: fixed;
    top: 70px;
    left: 1400px;
    width: 450px;
}
.instruction {
    position: fixed;
    top: 70px;
    left: 20px;
    width: 450px;
}
.my-header {
    font-size: 20px;
}
.my-title {
    font-size: 18px;
    text-decoration: underline;
}
.my-text {
    font-size: 16px;
}
</style>
